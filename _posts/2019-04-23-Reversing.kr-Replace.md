---
title: Reversing.kr--Replace
date: 2019-04-23 21:00:36
tags: [Reverse,Record]
categories: 
            - record
            - reverse
---

Replace 

先查看一下文件的信息，没有加壳。运行查看一下内容，发现是check输入，有一个'Wrong'的字符串，拖入ida分析。
搜索字符串发现还有'Correct'，根据字符串找到DialogFunc函数中调用，反编译后发现显然GetDlgItemInt()函数是接收输入的，只接收数字，不支持字母文本等。

之后在ida中没找到更好的方法继续分析下去，开始用OD进行动态调试。
搜索字符串找到'Correct'，找到其位置，发现其上方有连续两个jmp，根据情况应该都会跳走，如何改变条件使输出'Correct'成立是关键。

暂时看不出怎么使其判断成功，先在第一个jmp下个断不管。F9跑起来，到了断点的位置直接F8步过，继续此时发现了一个call，F7步入之后继续单步发现了另一个call，依旧是步入，进入后每次再单步就会结束程序，仔细查看发现是将eax指向的地址的指令置为nop

而寄存器eax的值之前是call Replace.00404689前传入的，进入call Replace.00404689之后又为 4084D0 加了 1，之后为40466F赋了值再call 40466F，这个call就是上方发现改变指令的函数，这也应该是输入不正确导致报错的函数，应该是eax指向的地址不合法。继续看，如果eax的指向地址合法的话很明显就会eax+1再进入第二个call 40466F，依旧会改变指令，我先不管怎么使他指向的地址合法，继续向下分析发现之后的jmp 指令会跳回到'Correct'的上方的jmp，但是依旧不会满足输出'Correct'，所以能不能使这个jmp变成nop就可以输出'Correct'，这样flag就可以拿到了。
接下来的目的就变成了怎样使eax指向的地址到0x401071,但根据测试的输入数据发现他加的数是0x6016055CB，这个数显然比需要到的地址小，这就需要一个eax的溢出，直接相减去掉'-'转化成10进制就可以得出 2687109798 .


